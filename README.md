## Порівняння Жадібного Алгоритму та Динамічного Програмування

Обидва алгоритми були випробувані для знаходження мінімальної кількості монет, необхідних для складання заданої суми, використовуючи монети номіналами 50, 25, 10, 5, 2 та 1. Виконання включало як базовий тест, так і тести продуктивності на великих сумах.

### Результати Виконання

Базові тести показали, що обидва алгоритми видають однаковий результат для суми `113`, ефективно визначаючи оптимальну кількість монет.

При тестуванні продуктивності на великих сумах було виявлено значну різницю у часі виконання між жадібним алгоритмом та алгоритмом динамічного програмування. Жадібний алгоритм показав значно кращу продуктивність з мінімальним часом виконання, тоді як динамічне програмування вимагало значно більше часу, особливо на великих сумах.

### Порівняльна Таблиця

| Алгоритм | Набір Даних (сума) | Результат | Час Виконання (сек) | Big O Нотація |
|----------|---------------------|-----------|---------------------|---------------|
| Жадібний | 194,401             | {50: 3888, 1: 1} | 0.000198 | O(n) |
| Динамічний | 194,401             | {50: 3888, 1: 1} | 0.138744 | O(mn) |
| Жадібний | 9,612,659           | {50: 192253, 5: 1, 2: 2} | 0.008821 | O(n) |
| Динамічний | 9,612,659           | {50: 192253, 5: 1, 2: 2} | 6.243529 | O(mn) |
| Жадібний | 42,983,581          | {50: 859671, 25: 1, 5: 1, 1: 1} | 0.037632 | O(n) |
| Динамічний | 42,983,581          | {50: 859671, 25: 1, 5: 1, 1: 1} | 28.023515 | O(mn) |

### Висновки

- **Час Виконання**: Жадібний алгоритм значно швидший за алгоритм динамічного програмування на великих сумах, що підтверджує його ефективність для задачі знаходження мінімальної кількості монет в даній системі монет.

- **Big O Нотація**: Жадібний алгоритм має лінійну складність `O(n)`, де n — кількість монет. Динамічне програмування має складність `O(mn)`, де `m` — сума, а `n` — кількість номіналів монет. Це пояснює більш високу продуктивність жадібного алгоритму порівняно з динамічним програмуванням на великих сумах.

- **Оптимальність**: Обидва алгоритми видали однакові оптимальні результати для тестованих сум, хоча це не завжди може бути гарантовано для всіх систем монет у випадку жадібного алгоритму.

У висновку, жадібний алгоритм є більш підходящим для швидкого знаходження мінімальної кількості монет у системах, де він забезпечує оптимальне рішення, тоді як динамічне програмування є більш універсальним, але менш ефективним за часом виконання.